#A “design document” for your project in the form of a Markdown file called DESIGN.md that discusses, technically, how you implemented your project and why you made the design decisions you did. Your design document should be at least several paragraphs in length. Whereas your documentation is meant to be a user’s manual, consider your design document your opportunity to give the staff a technical tour of your project underneath its hood.

Website:
- We use Flask and Jinja templates to display an interactive website, Flask sessions help us to keep users logged in. Using the CS50 library (the SQL function specifically) we are able to discuss with our database, insert and modify values, and use the data to customize our website's pages (we made sure to prevent SQL injection attacks at every steps). Our website performs both client and server side verifications to ensure that all the data we insert in our database has the right format.
- We tried to implement a modern and original design to our pages, with a combination of pictures and graphics as backgorunds. All the pages are properly implemented to make our UI as user freindly as possible. Users are able to modify their password, their data (except for the email with which they registered), and most pages adapt to their progress in the housing-match process. Try to get an error (can be done by submitting the form with some fields left blank) to see our apology.html page!
- We require the users to register with a Harvard or Yale email, and check that using client-side and server-side verifications.

Matching Algorithm:
- The algorithm is done in three steps: (Every single step is done for hosts and guests seperately, which get assigned at the beginning of the program by looking at the _school_ field in the _users_ table in _hy.db_)
1. Formation of Unique Groups:  We start by categorizing the information provided by users in our form into two types: obligatory(_same_class, same_gender_) and optional(type of night variables - _party, alcohol, bed_hour_). The obligatory factors are non-negotiable preferences that form the foundation of our matching process. Based on these obligatory preferences, we divide students into 15 unique groups. These groups are essentially indexed 0 for no oreference, 1-4 for only same class preference, 5-8 for male and class preference, 9-12 for female and class preference, 13 for only male preference, 14 for only female preference. This ensures that essential requirements are met in every match.

2. Incorporation of Optional Preferences: Next, we use the optional preferences to fine-tune the matching process. This step focuses on aligning the expectations and desires for the stay, helping us pair guests and hosts from the same obligatory groups who are seeking a similar experience. We do this by matching the hosts and guests within the same preference group that have the smallest difference in their "_partiness_" factor which is calcualted based on their optional preferences. This is done by sorting all possible pairings based on their difference in "_partiness factor_", adn then iterating through them until either all guests or hosts in the group have found a match.

3. Dynamic Matching Process: If initial matches are not found, our algorithm dynamically shifts unmatched users to adjacent preference groups. This iterative process continues, increasing the likelihood of finding a compatible match, while still prioritizing the core obligatory preferences. We do that by essentially making a direct graph out of the groups where nodes 5-8 have a directed edge pointing to 13, 9-12 have a directed edge to 14, and 1-4, 13, and 14 have a directed edge to 0. At the end the unmatched users get matched with -1 to denote the lack of match

- The algorithm essentially uses the table users from hy.db(which contains all the users) as its input and the matches table(with columns user_id and match_id) as its output. The matches table is then used in app.py to either show the matched person of the user at the matches page or not. To implement this algorithm we make use of a lot of lists, dictionaries, and fucntions.
